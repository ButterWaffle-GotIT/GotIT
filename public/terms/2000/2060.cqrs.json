{
	"id": 2060,
	"slug": "cqrs",
	"term": {
		"ko": "CQRS",
		"en": "CQRS"
	},
	"aliases": ["Command Query Responsibility Segregation"],
	"summary": "읽기(쿼리)와 쓰기(커맨드) 모델을 분리하여 확장성과 성능을 높이는 아키텍처 패턴입니다.",
	"onelinerForNonTech": "읽기 전용 창구와 쓰기 전용 창구를 따로 만들어, 각자 빠르고 효율적으로 처리하게 하는 설계.",
	"description": "CQRS는 데이터 변경을 담당하는 쓰기 모델과 조회를 담당하는 읽기 모델을 분리합니다. 읽기 측은 조회 최적화(별도 스키마, 캐시, 복제본)로 확장하고, 쓰기 측은 도메인 규칙을 엄격히 적용합니다. 이벤트 소싱과 함께 사용하면, 쓰기 모델의 이벤트를 기반으로 읽기 저장소를 비동기적으로 갱신할 수 있습니다.",
	"tags": ["백엔드", "아키텍처", "MSA", "성능"],
	"primaryTag": "백엔드",
	"relatedIds": [2016, 2018, 2059, 2061],
	"confusableIds": [],
	"useCases": [
		{
			"role": "Dev",
			"text": "우리 서비스는 사용자 행동 로그처럼 쓰기(Write) 작업이 엄청 많고, 동시에 인기 게시물 조회처럼 읽기(Read) 작업도 많아서 서버 부하가 상당해요. CQRS 패턴을 적용해서 읽기 전용 모델이랑 쓰기 전용 모델을 완전히 분리해야 합니다."
		},
		{
			"role": "Dev",
			"text": "읽기 모델은 검색에 최적화된 형태로 데이터 구조를 바꿔서 조회 성능을 극대화하고, 쓰기 모델은 트랜잭션과 비즈니스 로직에 집중하게 만들 수 있어요. 각 모델의 특성에 맞게 최적화할 수 있는 거죠."
		},
		{
			"role": "PM",
			"text": "기존 시스템에서는 데이터가 조금만 많아져도 조회 응답이 느려져서 고객 불만이 많았어요. CQRS를 도입하면 읽기 요청이 아무리 많아져도 성능 저하 없이 빠르게 데이터를 보여줄 수 있으니 사용자 경험이 훨씬 좋아질 거예요."
		}
	],
	"keywords": [
		"cqrs",
		"command",
		"query",
		"읽기-쓰기 분리",
		"read model",
		"write model"
	],
	"level": "advanced",
	"updatedAt": "2025-11-13"
}
