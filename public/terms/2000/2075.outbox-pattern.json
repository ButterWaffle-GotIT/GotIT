{
	"id": 2075,
	"slug": "outbox-pattern",
	"term": {
		"ko": "아웃박스 패턴",
		"en": "Outbox Pattern"
	},
	"aliases": ["Transactional Outbox"],
	"summary": "로컬 트랜잭션과 이벤트 발행의 일관성을 위해, 같은 DB에 아웃박스 테이블로 이벤트를 저장한 뒤 별도 프로세스가 발행하는 패턴입니다.",
	"onelinerForNonTech": "주문 저장과 '주문됨' 알림을 한 번에 기록해두고, 나중에 안전하게 알림을 보내는 '발송 대기함'.",
	"description": "쓰기 트랜잭션 안에서 도메인 이벤트를 아웃박스 테이블에 함께 커밋하고, 폴링/체인지 데이터 캡처(CDC)로 메시지 브로커에 퍼블리시합니다. 분산 트랜잭션 없이도 정확히 한 번(exactly-once)에 가까운 전달을 달성합니다.",
	"tags": ["백엔드", "아키텍처", "MSA", "트랜잭션"],
	"primaryTag": "백엔드",
	"relatedIds": [2042, 2019, 2062, 2061],
	"confusableIds": [],
	"useCases": [
		{
			"role": "Dev",
			"text": "마이크로서비스에서 '주문 생성' 같은 DB 트랜잭션이랑 '주문 생성 이벤트 발행'을 하나의 원자적(Atomic) 작업으로 보장하기가 힘들어요. 아웃박스 패턴을 사용해서 같은 DB 트랜잭션 안에서 이벤트를 함께 저장하고, 별도의 프로세스가 발행하게 만들 수 있어요."
		},
		{
			"role": "Dev",
			"text": "DB 업데이트 후 이벤트 발행하다가 네트워크 문제로 실패하면 데이터 정합성이 깨지는데, 아웃박스 패턴 덕분에 DB 트랜잭션과 이벤트 발행을 같은 커밋 단위로 처리해서 '정확히 한 번(Exactly-once)'에 가까운 이벤트 전달을 보장할 수 있어요."
		},
		{
			"role": "PM",
			"text": "사용자가 결제하면 DB에 저장되는 것도 중요하지만, '결제 완료' 알림을 보내는 이벤트가 누락되면 안 되잖아요. 아웃박스 패턴으로 이벤트 발행이 보장되니까, 결제 같은 핵심 비즈니스 이벤트의 안정적인 처리에 대한 신뢰도가 높아지겠네요."
		}
	],
	"keywords": ["outbox", "cdc", "exactly-once", "트랜잭션", "이벤트 발행"],
	"level": "advanced",
	"updatedAt": "2025-11-13"
}
